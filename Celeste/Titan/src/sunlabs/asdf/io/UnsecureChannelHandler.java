/*
 * Copyright 2010 Sun Microsystems, Inc. All Rights Reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER
 *
 * This code is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2
 * only, as published by the Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * General Public License version 2 for more details (a copy is
 * included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License
 * version 2 along with this work; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA
 *
 * Please contact Sun Microsystems, Inc., 16 Network Circle, Menlo
 * Park, CA 94025 or visit www.sun.com if you need additional
 * information or have any questions.
 */
package sunlabs.asdf.io;

import java.io.EOFException;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.channels.SelectionKey;
import java.nio.channels.SocketChannel;

/**
 * A basic implementation of a plain ChannelHandler (no encryption, no compression, etc).
 * The low-level methods {@link #networkRead()} and {@link #networkWrite()} read and write data to/from the Channel.
 * The {@link #input(ByteBuffer)} and {@link #output(ByteBuffer)} methods are left to be implemented the extending class.
 */
public abstract class UnsecureChannelHandler implements ChannelHandler {
    protected SocketChannel socketChannel;
    /** The input data from the peer. */
    protected ByteBuffer inNetworkData;
    /** The output application data.  This will be transmitted to the peer via invocation of the {@link #networkWrite()} method. */
    protected ByteBuffer outApplicationData;
    /** The output network data.  This is transmitted to the peer via a {@link SocketChannel#write(ByteBuffer)} invocation. */
    protected ByteBuffer outNetworkData;
    /** The input application data.  This will be generated by the {@link #networkRead()} method which invokes {@link #input(ByteBuffer)}. */
    protected ByteBuffer inApplicationData;
    /** The number of milliseconds that this ChannelHandler may be unused before it is eligible to be closed and eliminated. */
    protected long timeoutMillis;
    /** The time, expressed in milliseconds since midnight, January 1, 1970 UTC, that this ChannelHandler will be closed and eliminated. See {@link #setExpirationTime(long)}. */
    protected long expireTime;
    protected SelectionKey selectionKey;

    /**
     * Construct an abstract object implementing the {@link ChannelHandler} interface.
     *
     * @param selectionKey
     * @param networkInputSize
     * @param networkOutputSize
     * @param applicationInputSize
     * @param applicationOutputSize
     * @param timeoutMillis
     */    
    public UnsecureChannelHandler(SelectionKey selectionKey, int networkInputSize, int networkOutputSize, int applicationInputSize, int applicationOutputSize, long timeoutMillis) {
        this.selectionKey = selectionKey;
        this.socketChannel = (SocketChannel) selectionKey.channel();
        this.inNetworkData = ByteBuffer.allocate(networkInputSize);
        this.outNetworkData = ByteBuffer.allocate(networkOutputSize);
        this.inApplicationData = ByteBuffer.allocate(applicationInputSize);
        this.outApplicationData = ByteBuffer.allocate(applicationOutputSize);
        this.timeoutMillis = timeoutMillis;
        this.expireTime = System.currentTimeMillis() + this.timeoutMillis;
    }

    public synchronized void networkRead() {
        try {
            // Since this ChannelHandler does no processing of the input data,
            // read the input data directly into the inApplicationData ByteBuffer.
            int nread = this.socketChannel.read(this.inApplicationData);
            if (nread < 0) {
                throw new EOFException(); // XXX will be caught below
            }
            this.inApplicationData.flip();
            this.input(this.inApplicationData);
            this.inApplicationData.compact();
        } catch (IOException e) {
            e.printStackTrace();
            try { this.socketChannel.close(); } catch (IOException e1) { }
        }            
    }

    public void networkWrite() {
        this.resetExpirationTime(System.currentTimeMillis());
        synchronized (this.outApplicationData) {
            this.outApplicationData.flip();
            try {
                while (this.outApplicationData.hasRemaining()) {
                    this.socketChannel.write(this.outApplicationData);
                }
            } catch (IOException e) {
                try { this.close(); } catch (IOException e1) { }
            } finally {
                this.outApplicationData.compact();
            }
        }
    }

    public void output(ByteBuffer data) {
        while (data.hasRemaining()) {
            ByteBuffer slice = data.slice();
            synchronized (this.outApplicationData) {
                int newLimit = Math.min(data.remaining(), this.outApplicationData.remaining());
                slice.limit(newLimit);
                data.position(data.position() + newLimit);
                this.outApplicationData.put(slice);
//              this.socketChannel.register(this.selectionKey.selector(), SelectionKey.OP_WRITE);
                this.networkWrite();
            }
        }
    }
    
    public long getExpirationTime() {
        return this.expireTime;
    }
    
    public long resetExpirationTime(long now) {
        return this.setExpirationTime(now + this.timeoutMillis);
    }

    public long setExpirationTime(long time) {
        return this.expireTime = time;
    }
    
    public ByteBuffer setApplicationInput(ByteBuffer buffer) {
        synchronized (this.inApplicationData) {
            ByteBuffer result = this.inApplicationData;
            this.inApplicationData = buffer;
            return result;
        }
    }
    
    public void close() throws IOException {
        try { this.socketChannel.close(); } catch (IOException e) { }
        this.selectionKey.cancel();        
    }
}
